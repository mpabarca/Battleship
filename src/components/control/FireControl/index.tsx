import { useCallback, useEffect, useRef, useState } from "react";
import type { CoordinatesType, ErrorType, GridType } from "../../../types";
import {
  COLUMNS_HEADER,
  ROWS_HEADER,
  transformLetterToNumber,
} from "../../../utils/game";

type InputType = {
  inputColumn: string;
  inputRow: string;
};

interface IFireControl {
  target: CoordinatesType | [0, 0];
  setTarget: React.Dispatch<React.SetStateAction<CoordinatesType>>;
  handleFire: () => void;
  setGrid: React.Dispatch<React.SetStateAction<GridType | null>>;
}

const initialValues: InputType = {
    inputColumn: "",
    inputRow: "",
  }

function FireControl({ target, setTarget, handleFire, setGrid }: IFireControl) {
  const [value, setValue] = useState<InputType>(initialValues);
  const rowInputRef = useRef<HTMLInputElement>(null);
  const buttonRef = useRef<HTMLButtonElement>(null)

  // memoize handleErrors to only update single error type on grid
  const handleErrors = useCallback((updates: Partial<ErrorType>) => {
    setGrid((prev) => {
      if(!prev) return prev;
      return {
      ...prev,
      errors: {
        ...prev.errors,
        ...updates
      }
    }})
  }, [setGrid])

  function handleChange(e: React.FormEvent<HTMLInputElement>): void {
    const { name, value: newValue } = e.currentTarget;
    if (newValue.length === 0) {
      const updated = { ...value, [name]: newValue };
      setValue(updated);
      setTarget([
        transformLetterToNumber(updated.inputColumn),
        updated.inputRow ? parseInt(updated.inputRow) : 0,
      ]);
      return;
    }
    if (name === "inputColumn") {
      const upperValue = newValue.toUpperCase();
      if (COLUMNS_HEADER.includes(upperValue)) {
        const updated = { ...value, inputColumn: upperValue };
        setValue(updated);
        handleErrors({ columnCriteria: false })
        setTarget([
          transformLetterToNumber(updated.inputColumn),
          updated.inputRow ? parseInt(updated.inputRow) : 0,
        ]);
        rowInputRef.current?.focus();
      } else {
        handleErrors({ columnCriteria: true })
      }
      return;
    }

    if (name === "inputRow") {
      // Generated by GPT: reg. exp. allows only numeric input
      if (/^\d+$/.test(newValue) && ROWS_HEADER.includes(parseInt(newValue))) {
        const updated = { ...value, inputRow: newValue };
        setValue(updated);
        handleErrors({ rowCriteria: false })
        setTarget([
          transformLetterToNumber(updated.inputColumn),
          updated.inputRow ? parseInt(updated.inputRow) : 0,
        ]);
        
        if (newValue.length >= 2 || parseInt(newValue) === 10) {
          buttonRef.current?.focus();
        }
      } else {
        handleErrors({ rowCriteria: true })
      }
      return;
    }
  }

  useEffect(() => {
    if (target[0] === 0 && target[1] === 0) setValue(initialValues)
  }, [target])

  function handleClick() {
    if (value.inputColumn.length > 0 && value.inputRow.length > 0) {
      handleFire();
      handleErrors({ emptyField: false })
    } else {
      handleErrors({ emptyField: true })
    }
  }

  return (
    <>
      <div className='flex gap-2 items-center justify-between'>
        <div className='flex gap-4 h-12'>
          <input
            name='inputColumn'
            value={value?.inputColumn}
            placeholder='A'
            className='w-10 h-full border-b-2 text-center placeholder:text-center'
            onChange={(e) => handleChange(e)}
          />
          <input
            name='inputRow'
            value={value?.inputRow}
            ref={rowInputRef}
            placeholder='5'
            className='w-10 h-full border-b-2 text-center placeholder:text-center'
            onChange={(e) => handleChange(e)}
          />
        </div>
        <button type='button' ref={buttonRef} className='w-24 h-12' onClick={handleClick}>
          Fire!
        </button>
      </div>
    </>
  );
}

export default FireControl;
